# Chapter 2 - How Programming Languages Model Asynchronous Program Flow

This folder contains the code examples for Chapter 2.

# NOTES

## Definitions

### Cooperative

These are tasks that yield voluntarily either by explicitly yielding or by calling a function that suspends the task when it can’t progress further before another operation has finished (such as making a network call). Most often, these tasks yield to a scheduler of some sort. Examples of this are tasks generated by async/await in Rust and JavaScript.

### Non-cooperative

Tasks that don’t necessarily yield voluntarily. In such a system, the scheduler must be able to pre-empt a running task, meaning that the scheduler can stop the task and take control over the CPU even though the task would have been able to do work and progress. Examples of this are OS threads and Goroutines (after GO version 1.14).

## Stackful and stackless

### Stackful coroutine (Rust futures geenrated by async/await)

- Each task has its own call stack
- Similar to the stack used by OS for its threads
- Suspendable at any point in the program => Whole stack is preserved

### Stackless coroutine (fibers)

- Share the stack with other tasks (one single call stack)
- Can't suspend because there is only one call stack
- Less memory used to store/restore information of each task's stack => More efficient

## Threads

### OS Threads

`1:1 threading = one task:one thread`

Created by the OS, the code for OS threads is shipped with the kernel code. Manage by the OS scheduler.

> Linux: Kernel thread

### User-level threads

Created by the user and the OS has no idea about this thread.

The user-level threads are operated by the Async Runtime which create a layer of abstraction to represents the concurrent tasks.

=> Give freedom to choose how we want to handle concurrent operations

## Green threads, stackful coroutines, fibers

`M:N threading = M tasks run concurrently : N threads`

The implementation of green threads and fibers implies that there is a runtime with a scheduler that schedule `M` tasks to run on `N` threads.

### Fibers

Fiber is a lightweight thread of execution

- Multitasking type: Cooperative (Non-preemptive) multitasking. Fiber yield themselves to run another fiber while executing.

Green threads and fibers use the same mechanism like OS threads:

- Setting up one stack for one task => `Stackful`
- Saving CPU's state
- Switch between threads (tasks) by doing `context switch`

Even though green threads and fibers are light weight compared to OS threads, you still have to save and restore registeres at every context switch. => Less efficient compared to alternatives

## Callback based approaches

The whole idea behind a callback-based approach is to save a pointer to a set of instructions we want to run later together with whatever state is needed. In Rust, this would be a closure.

- Callback-based approach is easy to implement and add to the existing program flow but it will make the program code a bit messier due to the out-of-order code design.

- It's hard to implement the callback-based approach to the non-garbage collector programming language like Rust because the strict ownership system. Hard to share data in Rust as well because the data is moved to be mutated in the closure.

- No context switch is an advantage
- Memory increases lineary because the closure or callback also spawn its own stack frame (or not) to handle the operations.

## Promises, futures, async/await

This is another example of `M:N threading`. Many tasks can run concurrently on one OS thread. Each task is represented as a `state machine`.

Promise in Javascript returns states `pending`, `fulfilled` and `rejected`.

## Coroutines and async/await

- Asymmetric: yields to the scheduler
- Symmetric: yieldes to the another desitnation (a different coroutine)

- `async`: compiler rewrites the normal function call into a future or a promise.

In Javascript:

```js
async function example() {
  // code implementation
}

function example() {
  return new Promise((resolve) => {
    // code implementation
  });
}
```

In Rust:

```rs
async fn run() -> () {}

Fn run() -> impl Future<Output = ()>
```

- `await`: yields control to the runtime scheduler (we mentioned earlier that stackful coroutines is cooperative multitasking so it must yields to the scheduler) => Task is `suspended` (task has its own stack) until the `future/promise` you're waiting has `finished`

### Pros and Cons of Stackful coroutines

- Need the support from compiler to leverage its full advantages
- Pre-emption can be hard, or impossible because tasks can't be stopped in the middle of a stack frame.
- Hard to debug because the program flow is not sequential
